redistributionswiid <-sjPlot::plot_frq(mer_pref$redis_relativo, title = "Redistribution SWIID",show.mean = T , show.values = F,show.n = F, axis.labels = NULL)
setwd("~/GitHub/meritocracy-preferences")
summary(mer_pref$redis_relativo)
# Chunk 2
knitr::opts_chunk$set(warning = FALSE,message = FALSE, cache = TRUE,results = "hold")
knitr::opts_knit$set(root.dir = "../")
options(scipen=999)
rm(list=ls())
options(knitr.kable.NA = '')
# Chunk 3
library(sjPlot)
library(sjmisc) # several functions,ej read_stata
library(descr)
library(memisc)  # codebook
library(psych) # cor2latex
library(corrplot) # graph correlations
library(lavaan)
library(stargazer)
library(semTools)
library(plyr) # count
library(dplyr)
#library(car) # recode
library(ggplot2)
#library(Hmisc)
library(tidyverse)
library(data.table)
library(stringr)
library(countrycode)
library(lme4)
library(texreg)
library(mice)
library(ggrepel) # for scatter labels in sjp.scatter
#library(semPlot)
library(haven)
library(sjlabelled)
library(kableExtra)
library(summarytools)
library(tidyselect)
library(magrittr)
library(semPlot)
#library(Hmisc)
library(knitr)
# Chunk 4
load(file = "input/data/original/issp.rda")
#load(url('https://raw.githubusercontent.com/franciscomeneses/bases/master/issp.rda'))
# Check data
#names(issp2009)
#sjPlot::view_df(issp2009)
### change variable names to lowercase
names(issp2009) <- tolower(names(issp2009))
### Check & generate IDs (v4: respondent, v5: country)
### Generate new sequential id individuals by country to merge
issp2009$id <- sequence(tabulate(issp2009$v5))
issp2009$idtem=issp2009$v5*10000
issp2009$id=issp2009$idtem + issp2009$id
# Chunk 5
# select
redistrib=issp2009[,c("v5","v33","v34","v36","v38","v39","id")]
# new names(issp2009)
redistrib$income_dif = redistrib$v33
redistrib$unemployed = redistrib$v34
redistrib$taxes     = redistrib$v36
redistrib$health    = redistrib$v38
redistrib$educ      = redistrib$v39
#Delete old variables
redistrib = redistrib[-c(2:6)]
stargazer(redistrib[-c(1,2)], type="html")
# Chunk 6
redistrib[3:7][redistrib[3:7] > 5] <- NA
stargazer(redistrib[-c(1,2)], type="html")
# Chunk 7
dim(redistrib)
# Chunk 8
get_labels(redistrib$income_dif)
redistrib[,3:7] <-sjlabelled::set_na(redistrib[,c("income_dif","unemployed", "taxes", "health", "educ")], na = c(8,9))
# Chunk 9
redistrib[3:7]=6-redistrib[3:7]
# Chunk 10
cfa_red1 <- '
# latent variables
redist =~ income_dif + unemployed + taxes
accum  =~ health + educ
'
# Chunk 11
# generate 5 multiple complete datasets
out <- mice(redistrib[3:7], m = 5)
D1 <- complete(out, 1)
D2 <- complete(out, 2)
D3 <- complete(out, 3)
D4 <- complete(out, 4)
D5 <- complete(out, 5)
# fit model for each complete dataset
fit1 <- cfa(cfa_red1, data = D1)
fit2 <- cfa(cfa_red1, data = D2)
fit3 <- cfa(cfa_red1, data = D3)
fit4 <- cfa(cfa_red1, data = D4)
fit5 <- cfa(cfa_red1, data = D5)
# predict scores for all models
p1 <- predict(fit1)
p2 <- predict(fit2)
p3 <- predict(fit3)
p4 <- predict(fit4)
p5 <- predict(fit5)
# compute 'average' across 5 sets of scores:
scores <- (p1 + p2 + p3 + p4 + p5) / 5
#Generate factor scores
scores_dat = as.data.frame(scores)
# Adaptar base para agregar factor scores (sacar todos NA)
redistrib_m = redistrib[rowSums(is.na(redistrib[3:7])) != 5, ]
# Merge with factor scores
redistrib_sco = cbind(redistrib, scores)
# Check
stargazer(redistrib_sco[, 8:9], type = "text")
# Save  factor scores
save(redistrib_sco, file = "input/data/proc/redistrib_sco.rda")
# Chunk 12
print(dfSummary(redistrib_sco, valid.col = FALSE, graph.magnif = 1),
max.tbl.height = 300, method = "render")
# Chunk 13
### Select
indepvar= issp2009 %>% dplyr::select(contains("_inc"), "sex","age","degree", "hompop", "v44", "v45", "movstatus"="v46", "v5","id")
### Recode sex
sex_plotbefore <- sjPlot::plot_frq(indepvar$sex, title ="Gender before")
indepvar$sex=ifelse(indepvar$sex==1,0,ifelse(indepvar$sex==2,1,NA))
sex_plotafter <- sjPlot::plot_frq(indepvar$sex, title ="Gender after")
cowplot::plot_grid(sex_plotbefore, sex_plotafter, ncol=2)
### Recode Age
# Age
agebefore<-sjPlot::plot_frq(indepvar$age, title = "Age before",show.mean = T , show.values = F,show.n = F, axis.labels = NULL, type = c("histogram"))
#which(indepvar$age > 85) # / 461 casos !
#which(indepvar$age < 15) # / 0 casos !
indepvar$age[indepvar$age > 85] = NA
# Categorical age
indepvar$age_c=indepvar$age
indepvar$age_c[indepvar$age_c <= 25] = 1
indepvar$age_c[indepvar$age_c > 25 & indepvar$age_c <=35] = 2
indepvar$age_c[indepvar$age_c > 35 & indepvar$age_c <=45] = 3
indepvar$age_c[indepvar$age_c > 45 & indepvar$age_c <=55] = 4
indepvar$age_c[indepvar$age_c > 55 & indepvar$age_c <=65] = 5
indepvar$age_c[indepvar$age_c > 65] = 6
ageafter <- sjPlot::plot_frq(indepvar$age_c, title = "Age after", show.na = T, axis.labels =   c("18-25","25 -35", "35-45", "45-55", "55,65", "65-85","NA(>85)"))
cowplot::plot_grid(agebefore, ageafter, ncol=2)
### Recode Education
degrebefore <-sjPlot::plot_frq(indepvar$degree, coord.flip = TRUE, title = "Degree before")
# Recode. Values over 5 are removed
indepvar$degree[indepvar$degree > 5]=NA
#### Dummy university
# Dummy university
indepvar$univ=indepvar$degree
indepvar$univ=ifelse(indepvar$univ<=4,0,
ifelse(indepvar$univ==5,1,NA))
degreafter<- sjPlot::plot_frq(indepvar$univ, coord.flip = TRUE, title = "Dummy university")
cowplot::plot_grid(degrebefore, degreafter, ncol=2)
### Recode Income
#stargazer(indepvar[1:41], type="html")
# Income (variables finish in _inc)
# Continuo
# Recode missings
# Para todos los paises, recode missings.
indepvar[1:41][indepvar[1:41] >= 9999990] <- NA
indepvar[1:41][indepvar[1:41] == 999990] =NA
indepvar[1:41][indepvar[1:41] == 999997] =NA
indepvar[1:41][indepvar[1:41] == 999998] =NA
indepvar[1:41][indepvar[1:41] == 999999] =NA
# Identificar ceros (para poder diferenciar de los NAs luego)
indepvar[1:41][indepvar[1:41] == 0] <- 111111
# Agregar ahora todos en un solo vector
indepvar$income=rowSums(indepvar[1:41],na.rm = TRUE)
indepvar$income[indepvar$income ==0]=NA
indepvar$income[indepvar$income ==1111]=0
#stargazer(indepvar[1:41], type="html")
#summary(indepvar$income)
### Recode Household income
# Household income
# Preparar numero de personas en household
indepvar$hompop[indepvar$hompop==99]=NA
# Ahora dividir el vector income por n° de personas en hogar
indepvar$hhincome=indepvar$income/indepvar$hompop
summary(indepvar$hhincome)
# Y ajustar NAs de la variable final ingreso continuo
indepvar$hhincome[indepvar$hhincome==0]= NA
indepvar$hhincome[indepvar$income==111111]= 0
indepvar$hhincome[indepvar$hompop==0]= NA
#Wsummary(indepvar$hhincome)
# check
income=indepvar[c("v5", "ar_inc", "hompop","income",
"hhincome")]
# View(income)
# Generar quintiles de ingreso
indepvar %>% group_by(v5) %>% mutate(quintile =
ntile(hhincome,5)) ->indepvar
# Check
#prop.table(table(indepvar$v5,indepvar$quintile),1)*100
# Generar quintiles con NA como categoria
indepvar$quintile_miss=indepvar$quintile
indepvar$quintile_miss[is.na(indepvar$quintile_miss)] = 6
sjPlot::plot_frq(indepvar$quintile_miss, coord.flip = TRUE, title = "Quintiles de ingreso" , axis.labels=c("quintile 1","quintile 2","quintile 3","quintile 4","quintile 5","Miss"))
#stargazer(indepvar$quintile_miss, type = "html")
### Recode Subjetive status
# Subjective status
# Individual
#freq(indepvar$v44)
indepvar$sstatus=indepvar$v44
indepvar$sstatus[indepvar$ssttus>10]=NA
#freq(indepvar$sstatus)
# Family
#freq(indepvar$v45)
indepvar$f_sstatus=indepvar$v45
indepvar$f_sstatus[indepvar$f_sstatus>10]=NA
#freq(indepvar$f_sstatus)
movestatusbefore <- sjPlot::plot_frq(indepvar$movstatus, coord.flip = TRUE, title = "Subjective status mobility before")
indepvar$movstatus[indepvar$movstatus>=8]= NA
indepvar$movstatus <- car::recode(indepvar$movstatus,recodes ="c(1,2)=2;3=1;c(4,5)=3;c(6,7)=4")
indepvar$movstatus <- set_labels(indepvar$movstatus,labels = c("Sin movilidad"=1,
"Mov. Ascendente"=2,
"Mov. Descendente"=3,
"Indeterminado"=4))
movestatusafter <- sjPlot::plot_frq(indepvar$movstatus, coord.flip = TRUE, title = "subjective status mobility after")
cowplot::plot_grid(movestatusbefore, movestatusafter, ncol=2)
# Chunk 14
#Codigos por incorporar: se deben hacer ajustes de moneda y partidos por pais.
# Home value (ver Nota 3)
#summary(indepvar$v67)
# Party
#freq(issp2009$party_lr)
#prop.table(table(indepvar$v5,indepvar$party_lr),1)*100
# paises sin datos: CL, CN, CY, HU, IL, TW
#freq(indepvar$cl_prty) # estan
#freq(indepvar$cn_prty) # no
#freq(indepvar$cy_prty) # si
#freq(indepvar$hu_prty) # si
#freq(indepvar$il_prty) # si
#freq(indepvar$tw_prty) # si
# para usarlas habría que clasificar partidos de esos países
# Chunk 15
#Eliminar income por paises.
indepvar=indepvar[-c(1:41)]
dim(indepvar)
View(indepvar)
# Chunk 16
#indepvar_graph<-as.data.frame(indepvar[,2:16])
print(dfSummary(indepvar[-c(8)], valid.col = FALSE, graph.magnif = 1),
max.tbl.height = 300, method = "render")
# Chunk 17
# Rename
getahead = issp2009[, c("v6", "v7", "v9", "v10", "v11", "v12",
"v14", "v16", # get ahead
"v5", "id")]
getahead$wealthy = getahead$v6
getahead$pareduc = getahead$v7
getahead$ambition = getahead$v9
getahead$hwork = getahead$v10
getahead$people = getahead$v11
getahead$polcone = getahead$v12
getahead$race = getahead$v14
getahead$gender = getahead$v16
getahead = getahead[-c(1:8)]
# recode values 8 9 to NA
#freq(getahead$wealthy)
getahead[3:10][getahead[3:10] > 5] <- NA
#freq(getahead$gender) # check ok
stargazer(getahead, type = "html")
# adjust labels
get_labels(getahead$wealthy)
getahead[, 3:10][getahead[, 3:10] >= 8] <- NA
get_labels(getahead[3:10]) # check
# Reverse code for SEM models
getahead[3:10] = 6 - getahead[3:10]
# Generate variables with 3 values for getahead mess model categoric
#names(getahead)
getahead_temp = subset(getahead[c(2, 3:10)])
#names(getahead_temp)
getahead_temp[2:9][getahead_temp[2:9] <  4] <- 3
# freq(getahead_temp$hwork)
#freq(getahead$hwork)
colnames(getahead_temp) = paste("c3", colnames(getahead_temp),
sep = "")
names(getahead_temp)[names(getahead_temp) == "c3id"] <- "id"
getahead_temp2 = merge(getahead, getahead_temp, by = c("id"))
names(getahead_temp2) # ok
getahead = getahead_temp2
# Chunk 18
plot_likert((getahead[,3:8]),
geom.colors   = c("#9ecae1", "#6baed6","#4292c6",
"#2171b5"), # colorbrewer2.org
sort.frq      = "neg.asc", # sort descending)
title         = "getahead",
intercept.line.color = "white", # vertical middle
expand.grid   = F, # no inner margins in plot
show.n        = FALSE, # hide N's in axis labels
grid.range    = 1.8,
geom.size = 0.6) # expand axis 130% )
# Chunk 19
# Save object
#  save(getahead, file="../objects/getahead.rda")
# Chunk 20
#names(issp2009)
detearn = issp2009[, c("v47", "v48", "v49", "v50", "v51",
"v52", "v5", "id")]
#names(detearn)
detearn$respons 	= detearn$v47
detearn$yeduc  	  = detearn$v48
detearn$family    = detearn$v49
detearn$child     = detearn$v50
detearn$welljob   = detearn$v51
detearn$hardjob   = detearn$v52
#names(detearn)
detearn = detearn[-c(1:6)]
#names(detearn)
# recode values 8 9 to NA
#summary(detearn)
# freq(detearn$respons)
detearn[3:8][detearn[3:8] > 5] <- NA
# freq(detearn$respons) # check ok
#knitr::kable(summary(detearn), "html")
# Out Portugal (no answer in well job item)
detearn[which(detearn$v5 == 620), ] = NA
# adjust labels ###PROB PORTUCAL!!!
#get_labels(detearn)
detearn[, 3:8][detearn[, 3:8] >= 8] <- NA
detearn$welljob <- sjlabelled::set_na(detearn$welljob, na = c(0))
#knitr::kable(summary(detearn), "html")
# freq(detearn$welljob) ## prob portugal
detearn$welljob[detearn$welljob == 0] = NA
#get_labels(detearn$welljob)
labels(detearn$welljob) = labels(detearn$respons)### PROB NOT SOLVED
# Reverse code for SEM models
detearn$respons <- as.numeric(detearn$respons)
detearn$yeduc <- as.numeric(detearn$yeduc)
detearn$family <- as.numeric(detearn$family)
detearn$child <- as.numeric(detearn$child)
detearn$welljob <- as.numeric(detearn$welljob)
detearn$hardjob <- as.numeric(detearn$hardjob)
# Chunk 21
sjPlot::plot_likert(detearn[, 3:8],
geom.colors   = c("#9ecae1", "#6baed6", "#4292c6", "#2171b5"), # colorbrewer2.org
cat.neutral = 3,
sort.frq      = "neg.asc", # sort descending)
title         = "Before detearn",
intercept.line.color = "white", # vertical middle
expand.grid   = F, # no inner margins in plot
show.n        = FALSE, # hide N's in axis labels
grid.range    = 1.8,
geom.size = 0.6) # expand axis 130% ))
detearn$respons = as.numeric(6 - detearn$respons)
detearn$yeduc = as.numeric(6 - detearn$yeduc)
detearn$family = as.numeric(6 - detearn$family)
detearn$child = as.numeric(6 - detearn$child)
detearn$welljob = as.numeric(6 - detearn$welljob)
detearn$hardjob = as.numeric(6 - detearn$hardjob)
sjPlot::plot_likert(detearn[,3:8],
geom.colors   = c("#9ecae1", "#6baed6", "#4292c6", "#2171b5"), # colorbrewer2.org
cat.neutral = 3,
sort.frq      = "neg.asc", # sort descending)
title         = "After detearn",
intercept.line.color = "white", # vertical middle
expand.grid   = F, # no inner margins in plot
show.n        = FALSE, # hide N's in axis labels
grid.range    = 1.8,
geom.size = 0.6) # expand axis 130% ))
freq(detearn$respons)
# Chunk 22
# 3. MEASURING BELIEFS & PERCEPTIONS ------ -
# 3.1 Define object --------------------- -------------------------------
#			load("./objects/getahead.rda")
#			load("./objects/detearn.rda")
#	names(getahead)
#	names(detearn)
merit_per_pref=merge(getahead,detearn, by=c("id","v5"))
#	names(merit_per_pref)
# Estimación del modelo c/ unmerit 2do orden
cfa_perpref2 <- '
# latent variables
merit =~ hwork + ambition
parent=~ wealthy + pareduc
backg=~ race + gender
network=~ people + polcone
unmerit=~ parent + backg + network # 2nd order
bmerit =~ welljob + hardjob
need=~ family + child
'
fit_perpref2 <- cfa(cfa_perpref2, data = merit_per_pref,missing = "ML")
#	  summary(fit_perpref2, fit.measures=TRUE,standardized=TRUE)
# Path model
semPaths(fit_perpref2,layout = "tree", rotation = 2,
intercepts = FALSE, style = "lisrel", curvePivot = TRUE,
sizeMan = 3.5, sizeLat = 6)
# Chunk 23
out <- mice(merit_per_pref[,c(3:10,19:24)], m=5)
# Chunk 24
# Multiple imputation (para recuperar missings en scores) - REVIEW THIS, command lavPredict from 2017 should predict with missing values therefore saving from multiple imputation
# generate 5 multiple complete datasets
D1 <- complete(out, 1)
D2 <- complete(out, 2)
D3 <- complete(out, 3)
D4 <- complete(out, 4)
D5 <- complete(out, 5)
# fit model for each complete dataset
fit1 <- cfa(cfa_perpref2, data = D1)
fit2 <- cfa(cfa_perpref2, data = D2)
fit3 <- cfa(cfa_perpref2, data = D3)
fit4 <- cfa(cfa_perpref2, data = D4)
fit5 <- cfa(cfa_perpref2, data = D5)
# predict scores for all models
p1 <- predict(fit1)
p2 <- predict(fit2)
p3 <- predict(fit3)
p4 <- predict(fit4)
p5 <- predict(fit5)
# compute 'average' across 5 sets of scores:
scores <- (p1 + p2 + p3 + p4 + p5) / 5
# Generate factor scores
scores_dat = as.data.frame(scores)
dim(scores_dat)
str(scores_dat)
summary(scores)
# Generate object with factor scores
dim(merit_per_pref)
dim(scores_dat)
merit_per_pref_sco = cbind(merit_per_pref, scores)
# Save object with factor scores
#	names(merit_per_pref_sco)
merit_per_pref_sco = merit_per_pref_sco[, c(1:2, 25:31)]
#	  save(merit_per_pref_sco,
#	  file="./objects/merit_per_pref_sco.rda")
# Chunk 25
indiv<- merge (indepvar, redistrib_sco, by = c("id"))
indiv <- merge (indiv,  merit_per_pref_sco, by = c("id"))
# Chunk 26
print(dfSummary(indiv, valid.col = FALSE, graph.magnif = 1),
max.tbl.height = 300, method = "render")
# Chunk 27
save(indiv, file="input/data/proc/indiv.rda")
# Chunk 28
agg_lm=aggregate(indiv, by=list(indiv$v5),FUN=mean, na.rm=TRUE)
colnames(agg_lm) <- paste("j", colnames(agg_lm), sep = "_")
table(agg_lm$j_v5)
agg_lm$v5=agg_lm$j_v5
mer_pref=merge(indiv,agg_lm, by="v5")
dim(mer_pref)
# Chunk 29
mer_pref$age_g = mer_pref$age - mer_pref$j_age
mer_pref$sex_g = mer_pref$sex - mer_pref$j_sex
mer_pref$univ_g = mer_pref$univ - mer_pref$j_univ
mer_pref$sstatus_g = mer_pref$sstatus - mer_pref$j_sstatus
summary(mer_pref$univ_g)
# Chunk 30
# Inequality swiid (4)
#load(url("https://raw.githubusercontent.com/franciscomeneses/bases/master/swiid8_3.rda"))
load("input/data/original/swiid8_3.rda")
# convertir desde formato original list a dataframe
swiid_summary <- swiid %>%  bind_rows() %>%
group_by(country, year) %>%
summarize_all(funs(mean, sd)) %>%
ungroup() %>% dplyr::rename(.dots=setNames(names(.),
str_replace(names(.), "_mean", ""))) %>%
dplyr::rename_(.dots=setNames(names(.),str_replace(names(.), "_sd", "_se")))
save(swiid_summary, file = "input/data/proc/swiid_summary.rda")
# Chunk 31
summary(swiid_summary$.dots...year)
swiid_summary09=subset(swiid_summary, .dots...year==2009)
# Chunk 32
# Generate equivalente country code
head(swiid_summary09$.dots...country)
as.numeric(swiid_summary09$country)
# Continuo
swiid_summary09$v5=countrycode(swiid_summary09$.dots...country,'country.name','iso3n')
str(swiid_summary09$v5)
# Categórico
swiid_summary09$v5c=countrycode(swiid_summary09$.dots...country,'country.name','iso3c')
str(swiid_summary09$v5c)
# Merge
#indepvar <- merge(swiid_summary09,indepvar,by=c("v5"))
#summary(indepvar$.dots..._1_gini_disp)
# Chunk 33
mer_pref<- merge(swiid_summary09,mer_pref, by=c("v5"))
# Chunk 34
mer_pref$gini_neto<- mer_pref$.dots...gini_disp
mer_pref$gini_mkt <- mer_pref$.dots...gini_mkt
# Chunk 35
mer_pref$redis_neto= as.numeric(mer_pref$gini_mkt - mer_pref$gini_neto)
mer_pref$redis_relativo = as.numeric(mer_pref$redis_neto / mer_pref$gini_mkt)
#hist(mer_pref$redis_relativo)
# Chunk 36
mer_pref$redis_bradley  <- as.numeric((1- mer_pref$gini_neto / mer_pref$gini_mkt) *100)
#hist(mer_pref$redis_bradley)
