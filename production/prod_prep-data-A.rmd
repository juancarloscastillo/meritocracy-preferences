---
title: "Data preparation"
date: "`r format(Sys.time(), '%A %d %B %Y %X')`"
css: "../input/bib/style.css"
output:
  html_document:
    number_sections: true
    toc: true
    toc_float:
        collapsed: false
    toc_depth: 2
    code_folding: "hide"
editor_options:
  chunk_output_type: console
---


```{r eval=FALSE, include=FALSE}
rmarkdown::render(input = "production/prod_prep-data-A.Rmd",output_format = "html_document",output_dir = "production/");browseURL(url = "production/prod_prep-data-A.html")
```

```{r include=FALSE}
knitr::opts_chunk$set(warning = FALSE,message = FALSE, cache = FALSE,results = "hold")
knitr::opts_knit$set(root.dir = "../")
options(scipen=999)
rm(list=ls())
options(knitr.kable.NA = '')
```

load packages
```{r}
library(sjPlot)
library(sjmisc) # several functions,ej read_stata
library(descr)
library(memisc)  # codebook
library(psych) # cor2latex
library(corrplot) # graph correlations
library(lavaan)
library(stargazer) 
library(semTools)
library(plyr) # count
library(dplyr)
library(car) # recode
library(ggplot2)
library(Hmisc)
library(tidyverse)
library(data.table)
library(stringr)
library(countrycode)
library(lme4)
library(texreg)
library(mice)
library(ggrepel) # for scatter labels in sjp.scatter	
library(semPlot)
library(haven)
library(sjlabelled) 
library(kableExtra)
library(summarytools)

#library(Hmisc)
```


# Open data & general adjustment

```{r}
issp2009=read_stata("input/data/original/ZA5400_v4-0-0.dta")
    names(issp2009) <- tolower(names(issp2009)) # change to small
    # Check data  
    #names(issp2009)
```


```{r}
# Check & generate IDs (v4: respondent, v5: country)
    tapply(issp2009$v4, issp2009$v5, mean, na.rm=TRUE)
    # Algunos paises (ej:826) tienen ids raros ...

# Generar nueva id secuencial individuos por paÃ?s para merges
    issp2009$id <- sequence(tabulate(issp2009$v5))
    tapply(issp2009$id, issp2009$v5, mean, na.rm=TRUE) # ok
    summary(issp2009$id)
    issp2009$idtem=issp2009$v5*10000  
    issp2009$id=issp2009$idtem + issp2009$id
```

# Measurement Merit & Getting ahead 

Note: object now generated from different
script (merit_per_pref.R; merit_per_pref.rda)

#  Measurement and Redistribution

## Data preparation, gen redistrib.rda     

  # v33: Gov. resp to reduce differences in income
  # v34: Gov. resp to provide decent s andard of living for
  # unemployed 
  # v36: People with high income should pay a larger / same
  # / smaller share of income in taxes than those with
  # low incomes       
  # v38: ok if people with high income can buy better health  
  # v39: ok if people with high income can buy better education 
  


```{r}
 table(issp2009$v33)
```

```{r}
  # Rename & define object
    #names(issp2009)  
    redistrib=issp2009[,c("v5","v33","v34","v36","v38","v39","id")] 
    redistrib$income_dif= redistrib$v33
    redistrib$unemployed= redistrib$v34
    redistrib$taxes     = redistrib$v36
    redistrib$health    = redistrib$v38
    redistrib$educ      = redistrib$v39
  
    #names(redistrib)
    redistrib=redistrib[-c(2:6)]
    stargazer(redistrib[-c(1,2)], type="html")  
  
  # Recode NAs
    freq(redistrib$income_dif)
    redistrib[3:7][redistrib[3:7] > 5] <- NA
    freq(redistrib$income_dif) # check ok    

    # adjust labels NAs
      get_labels(redistrib$income_dif)
     # set_na(redistrib[3:7]) <- c(8, 9) # SET_NA NO FUNCIONA. 
      get_labels(redistrib$income_dif) # check
 
  # Dataset with original code for sjp.likert graph 
      redistrib2=redistrib
  
  # Reverse code for SEM models
      redistrib[3:7]=6-redistrib[3:7]
      
  # Checks
      names(redistrib)
      dim(redistrib)
			aggregate(redistrib, by=list(redistrib$v5), FUN=mean, 
				na.rm=TRUE)
      
  # Save object
   #  save(redistrib, file="input/data/proc/redistrib.rda") 
 
```



```{r}
print(dfSummary(redistrib, valid.col = FALSE, graph.magnif = 0.75),
      max.tbl.height = 300, method = "render")
```



```{r}
# 2.5 Invariance
    # measurementInvariance(cfa_2, data = redistrib, group = "v5")      # No funciono la invarianza arreglar.

```



 End sec 2; saved objects
	  # redistrib.rda: clean & recoded
	  # redistrib_sco.rda : fac scores [por ahora en analysis]






# Preparation Individual & Macro variables. 

## Individual level variables 
```{r}
  indepvar=issp2009
	summary(indepvar$id)
	length(indepvar$id)

	# Sex
    
	sjPlot::plot_frq(indepvar$sex)
		indepvar$sex=ifelse(indepvar$sex==1,0, 
			ifelse(indepvar$sex==2,1,NA))  
		
  # Age
		sjPlot::plot_frq((indepvar$age))
		summary(indepvar$age)
		which(indepvar$age > 85) # / 461 casos !
		which(indepvar$age < 15) # / 0 casos !
		indepvar$age[indepvar$age > 85] = NA
		
		# Categorical age
		indepvar$age_c=indepvar$age
		indepvar$age_c[indepvar$age_c <= 25] = 1
		indepvar$age_c[indepvar$age_c > 25 & indepvar$age_c <=35] = 2
		indepvar$age_c[indepvar$age_c > 35 & indepvar$age_c <=45] = 3
		indepvar$age_c[indepvar$age_c > 45 & indepvar$age_c <=55] = 4
		indepvar$age_c[indepvar$age_c > 55 & indepvar$age_c <=65] = 5
		indepvar$age_c[indepvar$age_c > 65] = 6

		freq(indepvar$age_c)
		
  # Education
		sjPlot::plot_frq(indepvar$degree, coord.flip = TRUE)
		freq(indepvar$degree)
  	indepvar$degree[indepvar$degree > 5]=NA
  	freq(indepvar$degree)
		
		# Dummy university
  		indepvar$univ=indepvar$degree
  		indepvar$univ=ifelse(indepvar$univ<=4,0,
  			ifelse(indepvar$univ==5,1,NA))
    		freq(indepvar$univ)	
  
  # Income (variables finish in _inc)
 
		# Continuo
    		
	    # Recode missings
	     	#names(indepvar)
	    	freq(indepvar$cl_inc)
	    	summary(indepvar[182:222]) # missings vary (note 2)
	 
  	    	# Para todos, recode missings dÃ?gitos   	
  	    		indepvar[182:222][indepvar[182:222] >= 9999990] <- NA
  	    		indepvar[182:222][indepvar[182:222] == 999990] =NA
  	    		indepvar[182:222][indepvar[182:222] == 999997] =NA
  					indepvar[182:222][indepvar[182:222] == 999998] =NA
  					indepvar[182:222][indepvar[182:222] == 999999] =NA
  					
  					summary(indepvar[182:222])
  	
				# Checks
					summary(indepvar$cl_inc)
					summary(indepvar$ar_inc)
					
	    	# Identificar ceros (para poder diferenciar de los NAs luego)
	    		indepvar[182:222][indepvar[182:222] == 0] <- 111111

	    		incomes=indepvar[182:222]
	    		
	  		# Agregar ahora todos en un solo vector
					indepvar$income=rowSums(indepvar[182:222],na.rm = TRUE)
					length(indepvar$income)
					
					summary(indepvar$income)
					length(indepvar$income)
					head(indepvar[c("ar_inc","cl_inc", "income")])

					indepvar$income[indepvar$income ==0]=NA
					indepvar$income[indepvar$income ==1111]=0
					
					summary(indepvar$income)
					
					
			# Household income	
				
				# Preparar numero de personas en household
				freq(indepvar$hompop)
				indepvar$hompop[indepvar$hompop==99]=NA
				
			# Ahora dividir el vector income por nÂ° de personas en hogar
				indepvar$hhincome=indepvar$income/indepvar$hompop
				summary(indepvar$hhincome)
				freq(indepvar$hhincome)
	   
			# Y ajustar NAs de la variable final ingreso continuo
				indepvar$hhincome[indepvar$hhincome==0]= NA
				indepvar$hhincome[indepvar$income==111111]= 0
				indepvar$hhincome[indepvar$hompop==0]= NA
	
				freq(indepvar$hhincome)
	
			#	check 
				income=indepvar[c("v5", "ar_inc", "hompop","income", 
					"hhincome")]
			#	View(income)   

		# Generar quintiles de ingreso
				indepvar %>% group_by(v5) %>% mutate(quintile =
						ntile(hhincome,5)) ->indepvar
	
			# Check
				freq(indepvar$quintile)
				prop.table(table(indepvar$v5,indepvar$quintile),1)*100
				
			# Generar quintiles con NA como categorÃ?a
				indepvar$quintile_miss=indepvar$quintile
				freq(indepvar$quintile_miss)
				indepvar$quintile_miss[is.na(indepvar$quintile_miss)] = 6
				freq(indepvar$quintile_miss)

  # Subjective status
    
		# Individual		
			freq(indepvar$v44)
			indepvar$sstatus=indepvar$v44
			indepvar$sstatus[indepvar$ssttus>10]=NA
  		freq(indepvar$sstatus)
    	
    # Family
			freq(indepvar$v45)
			indepvar$f_sstatus=indepvar$v45
    	indepvar$f_sstatus[indepvar$f_sstatus>10]=NA
  		freq(indepvar$f_sstatus)
	
  # Party
    freq(issp2009$party_lr)
		prop.table(table(indepvar$v5,indepvar$party_lr),1)*100
		# paises sin datos: CL, CN, CY, HU, IL, TW
		freq(indepvar$cl_prty) # estan 
		freq(indepvar$cn_prty) # no
		freq(indepvar$cy_prty) # si
		freq(indepvar$hu_prty) # si
		freq(indepvar$il_prty) # si
		freq(indepvar$tw_prty) # si
		
		# para usarlas habrÃ?a que clasificar partidos de esos paÃ?ses

	# Home value (ver Nota 3)
		freq(indepvar$v67)

```

# 3.2 Indep macro var 
```{r}
		
	# Inequality swiid (4)         
	swiid =	read_stata("input/data/original/swiid8_2.dta")

		# convertir formato original list a dataframe
#			swiid_summary <- swiid %>%  bind_rows() %>%
#				group_by(country, year) %>%  
#				summarize_all(funs(mean, sd)) %>% 
#				ungroup() %>% rename(.dots=setNames(names(.), 
#				str_replace(names(.), "_mean", ""))) %>%  
#				rename_(.dots=setNames(names(.), 
#     	str_replace(names(.), "_sd", "_se")))
		
	#		names(swiid_summary)
#table(swiid_summary$.dots...year)
		# Filter only 2009
		
#			swiid_summary09=subset(swiid_summary, .dots...year==2009)
			
		# Merge with indepvar object
			
			# Generate equivalente country code		
			
#				table(swiid_summary09$.dots...country)
#				as.numeric(swiid_summary09$country)
			  
				# Continuo
#				swiid_summary09$v5=countrycode(swiid_summary09$.dots...country,'country.name','iso3n')
#				swiid_summary09$v5
#				str(swiid_summary09$v5)
				
				# CategÃ³rico
#				swiid_summary09$v5c=countrycode(swiid_summary09$.dots...country,'country.name','iso3c')
#				str(swiid_summary09$v5c)
				
			# Merge
#				indepvar <- merge(swiid_summary09,indepvar,by=c("v5"))
#				freq(indepvar$.dots..._1_gini_disp)
#				summary(indepvar$.dots..._1_gini_disp)
				
			# check
#aggregate(indepvar[c("v5","gini_net")],list(indepvar$.dots...country,indepvar$v5c.x),mean) #Buscar como #agregar la variable
		
	# Quality of government
		# los objetos se generan en la sintax qog_explore

		# Merge qog
#			load("input/data/proc/qog_merit.rda")
#			names(qog_merit)
#			indepvar <- merge(qog_merit,indepvar,by=c("v5"))
#		#	freq(indepvar$wdi_gini)
#			
#		# Generate object
#			#names(indepvar)	
#	#		save(indepvar, file="input/data/proc/indepvar.rda")
#		
## End sec 3 objeto: indepvar.rda -------
#
			
			
		
```


```{r}
load(file = "input/data/proc/indepvar.rda")

print(dfSummary(indepvar, valid.col = FALSE, graph.magnif = 0.75),
      max.tbl.height = 300, method = "render")
```



```{r}
# 5. MODELS B: PREFERENCES  

# 5.1 Data preparation
  
  # Load & merge
  
	  #load("input/data/proc/indepvar.rda")
	  #names(indepvar)
	  #load("input/data/proc/redistrib.rda")
		#names(redistrib)
		length(redistrib$accum)
		
		
		#aggregate(redistrib[c("redist","accum")],by=list(v5),FUN=mean, na.rm=TRUE)
		
		# Check legths for merge
		#	length(indepvar$id)
		#	summary(indepvar$id)
		#  length(redistrib$id)
		#  summary(redistrib$id)
			
	  # Merge  (to the x, indepvar, largest)
		#  pref=merge(redistrib, indepvar, by=c("id"), all.x = TRUE)
		#  names(pref)
			
		# Check
		#  dim(pref)
		# 	length(pref$v5.x)
		#  aggregate(pref[c("v5.x","gini_net","redist")], 
		#  	list(pref$country, pref$v5c),mean, na.rm=TRUE)
	#  mean(pref$redist, na.rm=TRUE)
	#	  pref$v5=pref$v5.x
		  
	#	  summary(pref$redist)
	#	  summary(pref$id)
		  
	# Generate level 2 aggregated vars
	#	names(pref)
	#	agg_lm=aggregate(pref[c(4:10,22:42)], by=list(pref$v5), 
	#		FUN=mean,	na.rm=TRUE)
	#	names(agg_lm)
	#	dim(agg_lm)
		
	#	colnames(agg_lm) <- paste("j", colnames(agg_lm), sep = "_")
	 # 	names(agg_lm)
	  # agg_lm$v5=agg_lm$j_v5	
	  	
	#  pref2=merge(pref,agg_lm, by="v5")	
	#	pref=pref2
	#  dim(pref)
		
	# Group mean centering
  #  pref$age_g=age-j_age	
  #  pref$sex_g	=sex-j_sex
  #  pref$univ_g =univ-j_univ
  #  pref$sstatus_g= sstatus-j_sstatus
  #  
  #  summary(pref$univ_g)
  #  names(pref)
    
  # Save
  #  save(pref, file = "input/data/proc/pref.rda")
    
```

```{r}
# 6.1 Data preparation - meritocracy.rda  
  
  # Load & merge
#  load("input/data/proc/getahead.rda")
#	  load("input/data/proc/indepvar.rda")
#	  #names(indepvar)
#	  load("input/data/proc/merit_per_pref_sco.rda")
#		#names(merit_per_pref_sco)
#		
		# Check legths for merge
#			length(indepvar$id)
#			summary(indepvar$id)
#		  length(getahead$id)
#		  summary(getahead$id)
			
	  # Merge  (to the x, indepvar, largest)
#		  meritocracy=merge(merit_per_pref_sco, indepvar, by=c("id"))
#		  #names(meritocracy)
			
#		# Check
#		  dim(meritocracy)
#		 	length(meritocracy$v5.x)
#		  #aggregate(meritocracy[c("v5.x","gini_net","merit")], 
		  #	list(meritocracy$country, meritocracy$v5.x),mean, na.rm=TRUE)
#		  mean(meritocracy$merit, na.rm=TRUE)
#		  meritocracy$v5=meritocracy$v5.x
		  
	# Generate level 2 aggregated vars
#		names(meritocracy)
		#agg_lm=aggregate(meritocracy,by=list(meritocracy$v5c),
		#	FUN=mean,	na.rm=TRUE)
#		names(agg_lm)
#		dim(agg_lm)
		
#		colnames(agg_lm) <- paste("j", colnames(agg_lm), sep = "_")
#	  	names(agg_lm)
#	  agg_lm$v5=agg_lm$j_v5	
#	  meritocracy2=merge(meritocracy,agg_lm, by="v5")	
#	  dim(meritocracy2)
#		meritocracy=meritocracy2
#	  dim(meritocracy)
	  
		
	# Group mean centering
#    meritocracy$age_g=meritocracy$age-meritocracy$j_age	
#    meritocracy$sex_g	=meritocracy$sex-meritocracy$j_sex
#    meritocracy$univ_g =meritocracy$univ-meritocracy$j_univ
#  meritocracy$sstatus_g= meritocracy$sstatus-meritocracy$j_sstatus
    
#    summary(meritocracy$univ_g)
  #  names(meritocracy)
    
  # Save
 #   save(meritocracy, file = "input/data/proc/meritocracy.rda")
	  

```









